namespace TestDynamo.Model.Compiler

open System
open TestDynamo.Model.Compiler.Lexer
open TestDynamo.Utils

type AccessorType =
    | Attribute of string
    /// <summary>
    /// An attribute which has already been parsed and resolved and may contain
    /// invalid expression characters
    /// </summary>
    | RawAttribute of string
    | ExpressionAttrName of string
    | ListIndex of uint

    with
    override this.ToString() =
        match this with
        | RawAttribute x -> x
        | Attribute x -> x
        | ExpressionAttrName x -> x
        | ListIndex i -> $"[{i}]"

/// <summary>
/// A synthetic AST node is not parsed from a text token
/// It is generated by the compiler during compilation in a kind of Ast tree re-write
/// </summary>
type SyntheticAst =
    | AccessorPath of AccessorType list
    | CsvList of AstNode list
    | Projections of AstNode
    | IndividualSetUpdate of struct (AstNode * AstNode)
    | IndividualRemoveUpdate of AstNode
    | IndividualAddUpdate of struct (AstNode * AstNode)
    | IndividualDeleteUpdate of struct (AstNode * AstNode)

    with
    override this.ToString() =
        match this with
        | AccessorPath x -> x.ToString()
        | CsvList x -> x.ToString()
        | IndividualDeleteUpdate struct (l, r) -> $"{l} {r}"
        | IndividualAddUpdate struct (l, r) -> $"{l} {r}"
        | IndividualRemoveUpdate x -> x.ToString()
        | IndividualSetUpdate (x, y) -> $"{x} = {y}"
        | Projections x -> x.ToString()

and AstNode =
    | Accessor of AccessorType
    | ExpressionAttrValue of string
    | Call of struct (string * AstNode voption)
    | Between of struct (AstNode * struct (AstNode * AstNode))
    | BinaryOperator of struct (BinaryOpToken * struct(AstNode * AstNode))
    | UnaryOperator of struct (UnaryOpToken * AstNode)
    | Update of struct (UpdateExpressionVerb * AstNode)
    | Updates of AstNode list
    | EmptyParenthesis
    | Synthetic of SyntheticAst

    with
    override this.ToString() =
        match this with
        | Accessor x -> x.ToString()
        | Synthetic x -> x.ToString()
        | ExpressionAttrValue x -> x
        | Call (name, ValueNone) -> $"{name}()"
        | Call (name, ValueSome node) -> $"{name}({node})"
        | Between (x, (low, high)) -> $"{x} BETWEEN {low} AND {high}"
        | BinaryOperator (Multi Comma, (l, r)) -> $"{l}, {r}"
        | BinaryOperator (token, (l, r)) -> $"{l} {token} {r}"
        | UnaryOperator (token, operand) -> $"{token} {operand}"
        | EmptyParenthesis -> "()"
        | Update x -> x.ToString()
        | Updates xs -> Seq.map toString xs |> Str.join " "

    static member name = function
        | Accessor _ -> nameof Accessor
        | Synthetic _ -> nameof Synthetic
        | ExpressionAttrValue _ -> nameof ExpressionAttrValue
        | Call _ -> nameof Call 
        | Between _ -> nameof Between 
        | BinaryOperator _ -> nameof BinaryOperator
        | UnaryOperator _ -> nameof UnaryOperator 
        | EmptyParenthesis -> nameof EmptyParenthesis 
        | Update _ -> nameof Update 
        | Updates _ -> nameof Updates 

/// <summary>
/// Is used as a cache key in expression compiler.
/// Should be cachable
/// </summary>
[<CustomEquality; CustomComparison>]
type ParserSettings =
    { functionNames: string array
      updateFunctionVerbs: bool }

    with
    static member private arrayComparer: IComparer<string seq> = Comparison.seqComparer<string>
    static member private arrayEqComparer: IEqualityComparer<string array> = Comparison.arrayComparer<string> 2

    interface IComparable with
        member this.CompareTo obj =
            match obj with
            | :? ParserSettings as y ->
                match struct (this, y) with
                | { updateFunctionVerbs = false }, { updateFunctionVerbs = true } -> -1
                | { updateFunctionVerbs = true }, { updateFunctionVerbs = false } -> 1
                | { functionNames = fn1 }, { functionNames = fn2 } -> Comparison.seqComparer<string>.Compare(fn1, fn2)
            | _ -> invalidArg "obj" "cannot compare value of different types"

    override this.Equals(yobj) =
        match yobj with
        | :? ParserSettings as y ->
            this.updateFunctionVerbs = y.updateFunctionVerbs
                && ParserSettings.arrayEqComparer.GetHashCode(this.functionNames) = ParserSettings.arrayEqComparer.GetHashCode(y.functionNames)
                && ParserSettings.arrayEqComparer.Equals(this.functionNames, y.functionNames)
        | _ -> false

    override this.GetHashCode() =
        HashCode.Combine(this.updateFunctionVerbs, ParserSettings.arrayEqComparer.GetHashCode(this.functionNames))

module AstNode =

    let inline private addAcc struct (f, ast) acc = struct (f, acc, ast)  

    /// <summary>
    /// Apply function with an accumulator to each node in the tree
    /// If the function returns None, do not process any more children
    /// </summary>
    let partialDepthFirstSearch =
        let rec find = function

            // done
            | struct (f: OptimizedClosures.FSharpFunc<_, _, _, _>, []: struct (AstNode * int) list, acc) -> acc

            // no children
            | f, (AstNode.EmptyParenthesis & head, depth)::tail, acc
            | f, (AstNode.Call (_, ValueNone) & head, depth)::tail, acc
            | f, (AstNode.ExpressionAttrValue _ & head, depth)::tail, acc
            | f, (AstNode.Synthetic (AccessorPath _) & head, depth)::tail, acc
            | f, (AstNode.Accessor (AccessorType.ExpressionAttrName _) & head, depth)::tail, acc
            | f, (AstNode.Accessor (AccessorType.Attribute _) & head, depth)::tail, acc
            | f, (AstNode.Accessor (AccessorType.RawAttribute _) & head, depth)::tail, acc
            | f, (AstNode.Accessor (AccessorType.ListIndex _) & head, depth)::tail, acc ->
                match f.Invoke(depth, acc, head) with
                | ValueNone -> acc
                | ValueSome acc' -> find struct (f, tail, acc')

            // 1 child
            | f, (AstNode.Call (_, ValueSome next) & head, depth)::tail, acc
            | f, (AstNode.Update (_, next) & head, depth)::tail, acc
            | f, (AstNode.Synthetic (IndividualRemoveUpdate next) & head, depth)::tail, acc
            | f, (AstNode.Synthetic (Projections next) & head, depth)::tail, acc
            | f, (AstNode.UnaryOperator (_, next) & head, depth)::tail, acc ->
                match f.Invoke(depth, acc, head) with
                | ValueNone -> acc
                | ValueSome acc' -> find struct (f, (next, depth + 1)::tail, acc')

            // 2 children
            | f, (AstNode.Synthetic (IndividualDeleteUpdate (next1, next2)) & head, depth)::tail, acc
            | f, (AstNode.Synthetic (IndividualAddUpdate (next1, next2)) & head, depth)::tail, acc
            | f, (AstNode.Synthetic (IndividualSetUpdate (next1, next2)) & head, depth)::tail, acc
            | f, (AstNode.BinaryOperator (_, (next1, next2)) & head, depth)::tail, acc ->
                match f.Invoke(depth, acc, head) with
                | ValueNone -> acc
                | ValueSome acc' -> find struct (f, (next1, depth + 1)::(next2, depth + 1)::tail, acc')

            // 3 children
            | f, (AstNode.Between (next1, (next2, next3)) & head, depth)::tail, acc ->
                match f.Invoke(depth, acc, head) with
                | ValueNone -> acc
                | ValueSome acc' -> find struct (f, (next1, depth + 1)::(next2, depth + 1)::(next3, depth + 1)::tail, acc')

            // list
            | f, (Updates nexts & head, depth)::tail, acc
            | f, (AstNode.Synthetic (CsvList nexts) & head, depth)::tail, acc -> 
                match f.Invoke(depth, acc, head) with
                | ValueNone -> acc
                | ValueSome acc' -> find struct (f, (nexts |> List.map (flip tpl (depth + 1)))@tail, acc')

        fun f acc astNode ->
            let f' = OptimizedClosures.FSharpFunc<_, _, _, _>.Adapt f
            find struct(f', [(astNode, 0)], acc)


    /// <summary>
    /// Apply function with an accumulator to each node in the tree
    /// If the function returns None, do not process any more children
    ///
    /// The search algorithm is kinda depth first, kinda breadth first, optimised for tail call recursion
    /// </summary>
    let depthFirstSearch f = f >>>> ValueSome |> partialDepthFirstSearch

    let rec private toCsv' = function
        | struct(x1, []) -> x1
        | x1, [x2] -> AstNode.BinaryOperator (Multi Comma, (x1, x2))
        | x1, x2::xN -> AstNode.BinaryOperator (Multi Comma, (x1, x2)) |> flip tpl xN |> toCsv'

    /// <summary>
    /// Convert a list of nodes into a Csv node.
    /// Single nodes are just returned. Empty lists return none
    /// </summary>
    let toCsv = function
        | [] -> ValueNone
        | head::tail -> struct (head, tail) |> toCsv' |> ValueSome

    let rec private expand' xs = 
        Collection.foldBackL (fun s -> function
            | BinaryOperator (Multi Comma, (l, r)) -> expand' [l] @ expand' [r] @ s
            | x -> x::s) [] xs

    /// <summary>
    /// Recursively expand a csv node
    /// </summary>
    let expand x = expand' [x]